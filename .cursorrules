# Cursor Rules for RAC Rewards Application

## ðŸ“‹ **Documentation References**
- **Complete Product Features**: See `PRODUCT_FEATURES.md` for comprehensive feature specifications
- **Development Guidelines**: See `APPLICATION_STACK.md` for technical stack and best practices
**Web3 Investment Flow**: See `WEB3_INVESTMENT_FLOW_IMPLEMENTATION.md` for investment system details

#### C. Security & Compliance
- Secure seed phrase generation and storage
- OTP validation with 5-minute expiry
- Row Level Security (RLS) for data protection
- Secure wallet address management
- Terms of use and privacy policy acceptance tracking
- Blockchain transaction security
- NFT ownership verification

## Database Rules
- **HYBRID DATABASE ARCHITECTURE: Local PostgreSQL for Data + Supabase for Authentication**
  - **Data Operations**: Use local PostgreSQL database for all data storage and retrieval
  - **Authentication**: Use Supabase Cloud for user authentication and session management only
- Always use `public` schema for tables (not `api`)
- Use UUID for primary keys with `gen_random_uuid()`
- Follow existing enum patterns: `app_role`, `merchant_status`, `subscription_plan`
- Use `WHERE NOT EXISTS` instead of `ON CONFLICT` for safe insertions
- Loyalty card numbers: 8 characters, first character is user's initial (e.g., J0000001)

## Database Connection Requirements
- **MANDATORY: Hybrid Database Configuration**
  - **Local PostgreSQL for Data Operations**:
    - Host: `localhost` (or `127.0.0.1`)
    - Port: `5432`
    - Database: `ignite_rewards`
    - User: `postgres`
    - Password: From environment variables
    - URL: `postgresql://postgres:password@localhost:5432/ignite_rewards`
  - **Supabase Cloud for Authentication Only**:
    - URL: `https://wndswqvqogeblksrujpg.supabase.co`
    - Anon Key: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InduZHN3cXZxb2dlYmxrc3J1anBnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYzMzEyMTAsImV4cCI6MjA3MTkwNzIxMH0.eOXJEo3XheuB2AK3NlRotSKqPMueqkgPUa896TM-hfA`
- **Data Operations**: All CRUD operations, queries, and data storage must use local PostgreSQL
- **Authentication Operations**: User login, registration, session management use Supabase
- **NEVER mix data operations with authentication operations**

## Database Management Rules
- **Local PostgreSQL Management:**
  - Use direct PostgreSQL connections for data operations
  - Apply SQL scripts directly to local database using `psql` or database client
  - Use environment variables for database credentials
  - Always backup local database before major changes
- **Supabase Authentication Management:**
  - Use Supabase CLI only for authentication-related operations
  - Install Supabase CLI: `npm install -g supabase`
  - Link to cloud project: `supabase link --project-ref wndswqvqogeblksrujpg`
  - Use Supabase for user management, OAuth, and session handling
- **Migration Workflow:**
  1. For data schema changes: Apply directly to local PostgreSQL
  2. For authentication changes: Use Supabase CLI and cloud instance
  3. Always test changes in development environment first
  4. Document all database changes with clear migration scripts
- **Project Reference:** `wndswqvqogeblksrujpg` (from Supabase URL)
- **Migration File Naming:** `YYYYMMDD_description.sql`
- **Always backup before major migrations**

## Code Style
- Use TypeScript for all new code
- Follow existing component patterns in `src/components/`
- Use proper error handling with try-catch blocks
- Include proper TypeScript types for all functions

## SQL Best Practices
- Always check table structure before writing INSERT statements
- Use proper column names from actual database schema
- Include verification queries after data insertion
- Use `NOT EXISTS` for safe duplicate prevention

## Testing
- Create comprehensive test data with realistic values
- Include both custodial and non-custodial NFT types
- Test different subscription plans and user roles
- Verify all foreign key relationships

## Security Best Practices

### OWASP Top 10 Compliance
- **A01: Broken Access Control**
  - Implement proper authentication and authorization checks
  - Use Row Level Security (RLS) policies for all database tables
  - Validate user permissions before any data access
  - Implement principle of least privilege
  - Use JWT tokens with proper expiration and validation
  - Never trust client-side data for authorization decisions

- **A02: Cryptographic Failures**
  - Use strong encryption for sensitive data (AES-256)
  - Hash passwords with bcrypt (minimum 12 rounds)
  - Use HTTPS/TLS 1.3 for all communications
  - Implement proper key management and rotation
  - Encrypt data at rest in database
  - Use secure random number generation for tokens/seeds

- **A03: Injection**
  - Use parameterized queries and prepared statements
  - Validate and sanitize all user inputs
  - Implement input validation on both client and server
  - Use ORM/query builders to prevent SQL injection
  - Escape special characters in user-generated content
  - Implement Content Security Policy (CSP) headers

- **A04: Insecure Design**
  - Follow secure coding principles from design phase
  - Implement threat modeling for new features
  - Use secure defaults for all configurations
  - Implement proper error handling without information leakage
  - Design with security-by-default principles
  - Regular security architecture reviews

- **A05: Security Misconfiguration**
  - Remove default accounts and passwords
  - Disable unnecessary services and features
  - Keep all dependencies and frameworks updated
  - Use security headers (HSTS, CSP, X-Frame-Options)
  - Implement proper logging and monitoring
  - Regular security configuration audits

- **A06: Vulnerable and Outdated Components**
  - Maintain inventory of all dependencies
  - Regular dependency vulnerability scanning
  - Implement automated security updates where possible
  - Use tools like `npm audit` and `snyk` for vulnerability detection
  - Keep all libraries and frameworks current
  - Document and track all third-party components

- **A07: Identification and Authentication Failures**
  - Implement multi-factor authentication (MFA)
  - Use strong password policies (minimum 12 characters, complexity)
  - Implement account lockout after failed attempts
  - Use secure session management with proper timeouts
  - Implement proper logout functionality
  - Protect against credential stuffing attacks

- **A08: Software and Data Integrity Failures**
  - Implement code signing and integrity checks
  - Use secure CI/CD pipelines with signed artifacts
  - Implement supply chain security measures
  - Validate data integrity with checksums/hashes
  - Use secure update mechanisms
  - Implement tamper detection for critical data

- **A09: Security Logging and Monitoring Failures**
  - Implement comprehensive audit logging
  - Log all authentication and authorization events
  - Monitor for suspicious activities and anomalies
  - Implement real-time alerting for security events
  - Use centralized logging with proper retention
  - Regular log analysis and incident response procedures

- **A10: Server-Side Request Forgery (SSRF)**
  - Validate and sanitize all URLs and endpoints
  - Use allowlists for external service calls
  - Implement network segmentation
  - Use proper URL parsing and validation
  - Block access to internal/private networks
  - Implement request timeouts and size limits

### Database Security
- **HYBRID DATABASE SECURITY: Local PostgreSQL + Supabase Authentication**
  - **Local PostgreSQL Security**: Implement proper access controls and encryption
  - **Supabase Authentication Security**: Use cloud authentication with proper session management
- Use Row Level Security (RLS) policies for all local PostgreSQL tables
- **Data Operations**: All CRUD operations must use local PostgreSQL with proper security
- **Authentication Operations**: Use Supabase cloud for secure user authentication
- Never hardcode sensitive data in scripts or code
- Use environment variables for all database configuration
- Implement database connection encryption for local PostgreSQL
- Use parameterized queries exclusively for both databases
- Regular database security audits and updates
- Implement database access logging and monitoring for local PostgreSQL
- **NEVER store authentication data in local database**
- **NEVER store business data in Supabase cloud database**

## Hybrid Database Architecture Guidelines

### Data Flow Separation
- **Authentication Flow**: User login â†’ Supabase Auth â†’ Session token â†’ Local app
- **Data Flow**: App operations â†’ Local PostgreSQL â†’ Data storage/retrieval
- **User Profile Sync**: Supabase user ID â†’ Local PostgreSQL user records

### Implementation Rules
- **DatabaseAdapter Pattern**: Use the existing DatabaseAdapter class for proper separation
- **Authentication**: Always use `databaseAdapter.auth` for user authentication
- **Data Operations**: Always use `databaseAdapter.from(table)` for data operations
- **Environment Configuration**: Maintain separate configs for local DB and Supabase
- **Error Handling**: Handle authentication errors separately from data errors

### Security Boundaries
- **Authentication Boundary**: Supabase handles all user authentication and session management
- **Data Boundary**: Local PostgreSQL handles all business data and application state
- **Cross-Boundary Operations**: Use user ID from Supabase auth to link with local data
- **No Data Mixing**: Never store business data in Supabase or auth data in local PostgreSQL

### Application Security
- Implement Content Security Policy (CSP) headers
- Use secure HTTP headers (HSTS, X-Frame-Options, X-Content-Type-Options)
- Implement proper CORS policies
- Use secure cookie settings (HttpOnly, Secure, SameSite)
- Implement rate limiting for API endpoints
- Use secure random number generation for all tokens
- Implement proper error handling without information disclosure
- Regular security testing and penetration testing

### Wallet and Blockchain Security
- Secure seed phrase generation and storage
- Implement hardware wallet support where possible
- Use secure key derivation functions (PBKDF2, scrypt)
- Implement proper wallet backup and recovery procedures
- Secure smart contract interaction and validation
- Implement transaction signing security measures
- Regular security audits of blockchain integrations

## Accessibility Best Practices

### WCAG 2.1 AA Compliance
- **Perceivable**
  - Provide alternative text for all images
  - Use sufficient color contrast (4.5:1 for normal text, 3:1 for large text)
  - Implement proper heading structure (h1-h6 hierarchy)
  - Provide captions for video content
  - Use semantic HTML elements
  - Ensure text can be resized up to 200% without loss of functionality

- **Operable**
  - Ensure all functionality is keyboard accessible
  - Provide sufficient time for users to read and use content
  - Avoid content that causes seizures (no flashing more than 3 times per second)
  - Provide ways to help users navigate and find content
  - Implement focus indicators for keyboard navigation
  - Use proper ARIA labels and roles

- **Understandable**
  - Use clear and simple language
  - Implement consistent navigation and functionality
  - Provide clear error messages and help text
  - Use proper form labels and instructions
  - Implement logical reading order
  - Provide context for abbreviations and jargon

- **Robust**
  - Use valid, semantic HTML markup
  - Implement proper ARIA attributes
  - Ensure compatibility with assistive technologies
  - Use progressive enhancement principles
  - Test with screen readers and other assistive tools
  - Maintain compatibility across different browsers and devices

### React/TypeScript Accessibility
- Use semantic HTML elements in JSX
- Implement proper ARIA attributes (aria-label, aria-describedby, role)
- Use React accessibility libraries (react-aria, reach-ui)
- Implement keyboard event handlers for custom components
- Use proper form validation with accessible error messages
- Implement focus management for modals and dynamic content
- Use proper color contrast in CSS/styled components
- Test components with accessibility testing tools

### Testing and Validation
- Regular accessibility audits using automated tools
- Manual testing with screen readers (NVDA, JAWS, VoiceOver)
- Keyboard-only navigation testing
- Color contrast validation
- Regular security vulnerability scanning
- Penetration testing for critical features
- Code security reviews and static analysis

## File Organization
- SQL scripts: descriptive names with version numbers
- Documentation: clear markdown files with step-by-step instructions
- Test data: comprehensive and realistic
- Fixes: include rollback instructions when possible

MANDATORY: Pre-Development Checklist
BEFORE STARTING ANY WORK: Run npm run lint to see current state
BEFORE COMMITTING: Run npm run lint --fix to auto-fix issues
BEFORE PUSHING: Ensure ZERO linting errors
DAILY: Clean up any accumulated linting issues
WEEKLY: Run comprehensive linting audit
Code Quality Rules
NEVER: Use any types - always specify proper TypeScript interfaces
NEVER: Leave console.log statements in production code
NEVER: Commit unused imports or variables
NEVER: Use direct hasOwnProperty access - use Object.prototype.hasOwnProperty.call()
NEVER: Include unnecessary escape characters in regex patterns
ALWAYS: Use proper TypeScript types for all function parameters
ALWAYS: Remove debug code before committing
ALWAYS: Clean up template code and unused variables
AI Code Generation Guidelines
NEVER: Include console.log statements in generated code
NEVER: Use any types - always specify proper interfaces
ALWAYS: Remove unused imports after code generation
ALWAYS: Use proper TypeScript types for all parameters
ALWAYS: Clean up template code and remove unused variables
ALWAYS: Review and clean up generated code before committing
Development Workflow Rules
Start of Day: Run npm run lint to see current state
Before Coding: Fix any existing linting issues
During Coding: Use Cursor's real-time linting features
Before Commit: Run npm run lint:fix to auto-fix issues
End of Day: Clean up any accumulated issues
Code Review: Check for unused imports, console statements, and any types
Linting Error Prevention
Unused Variables/Imports: Remove immediately when identified
TypeScript any Types: Replace with proper interfaces
Console Statements: Remove before committing (except in test files)
Regex Escape Issues: Use proper regex patterns without unnecessary escapes
Prototype Access: Use Object.prototype.hasOwnProperty.call() instead of direct access
Emergency Cleanup Rules
If Linting Issues Accumulate: Stop feature development and clean up first
Priority Order: Fix errors first, then warnings
Batch Processing: Fix similar issues together (all console statements, all unused imports)
Verification: Run npm run build after cleanup to ensure no build errors