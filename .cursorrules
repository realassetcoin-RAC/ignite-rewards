# Cursor Rules for RAC Rewards Application

## ðŸ“‹ **Documentation References**
- **Complete Product Features**: See `PRODUCT_FEATURES.md` for comprehensive feature specifications
- **Development Guidelines**: See `APPLICATION_STACK.md` for technical stack and best practices
**Web3 Investment Flow**: See `WEB3_INVESTMENT_FLOW_IMPLEMENTATION.md` for investment system details

#### C. Security & Compliance
- Secure seed phrase generation and storage
- OTP validation with 5-minute expiry
- Row Level Security (RLS) for data protection
- Secure wallet address management
- Terms of use and privacy policy acceptance tracking
- Blockchain transaction security
- NFT ownership verification

## Database Rules
- **CRITICAL: ONLY use Docker PostgreSQL Database** - All database operations must connect to Docker PostgreSQL
- Always use `public` schema for tables (not `api`)
- Use UUID for primary keys with `gen_random_uuid()`
- Follow existing enum patterns: `app_role`, `merchant_status`, `subscription_plan`
- Use `WHERE NOT EXISTS` instead of `ON CONFLICT` for safe insertions
- Loyalty card numbers: 8 characters, first character is user's initial (e.g., J0000001)
- All database operations must use the Docker PostgreSQL instance at `localhost:5432`
- Use Supabase ONLY for authentication (Google OAuth, social login)
- Data operations (CRUD, queries) must use Docker PostgreSQL

## Database Connection Requirements
- **MANDATORY: Use Docker PostgreSQL Database for Data Operations**
  - Host: `localhost`
  - Port: `5432`
  - Database: `ignite_rewards`
  - User: `postgres`
  - Password: `Maegan@200328`
  - Connection String: `postgresql://postgres:Maegan@200328@localhost:5432/ignite_rewards`
- **Docker Container Information**
  - Container Name: `rac-rewards-postgres-dev`
  - Image: `rac-rewards/postgres:dev`
  - Check status: `docker ps | findstr postgres`
  - View logs: `docker logs rac-rewards-postgres-dev`
  - Restart: `docker restart rac-rewards-postgres-dev`
- **Supabase Cloud for Authentication Only**
  - URL: `https://wndswqvqogeblksrujpg.supabase.co`
  - Anon Key: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InduZHN3cXZxb2dlYmxrc3J1anBnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYzMzEyMTAsImV4cCI6MjA3MTkwNzIxMH0.eOXJEo3XheuB2AK3NlRotSKqPMueqkgPUa896TM-hfA`
  - Use only for: `auth.signIn()`, `auth.signOut()`, `auth.getSession()`, `auth.onAuthStateChange()`
- **NEVER mix data operations with authentication**
- All SQL scripts and database operations must target Docker PostgreSQL
- When creating tables, functions, or policies, apply directly to Docker PostgreSQL

## Docker PostgreSQL Usage Rules
- **MANDATORY: Use Docker PostgreSQL for All Database Operations**
  - Start Docker Desktop before development
  - Ensure container is running: `docker ps | findstr postgres`
  - Connect via psql: `docker exec -it rac-rewards-postgres-dev psql -U postgres -d ignite_rewards`
  - Execute SQL files: `docker exec -i rac-rewards-postgres-dev psql -U postgres -d ignite_rewards < script.sql`
  - Backup database: `docker exec rac-rewards-postgres-dev pg_dump -U postgres ignite_rewards > backup.sql`
- **Database Migration Workflow:**
  1. Create SQL migration files in `migrations/` directory
  2. Test locally in Docker PostgreSQL first
  3. Apply using: `node scripts/apply-migration.js migration-file.sql`
  4. Verify changes with: `docker exec -it rac-rewards-postgres-dev psql -U postgres -d ignite_rewards -c "\dt"`
  5. Always backup before major migrations
- **Migration File Naming:** `YYYYMMDD_HHMMSS_description.sql`
- **Always backup before major migrations**
- **Development Setup:**
  1. Ensure Docker Desktop is running
  2. Run `docker-compose up -d` to start all services
  3. Application connects to Docker PostgreSQL automatically
  4. PgAdmin available at `http://localhost:8080` (admin@admin.com / admin)

## Code Style
- Use TypeScript for all new code
- Follow existing component patterns in `src/components/`
- Use proper error handling with try-catch blocks
- Include proper TypeScript types for all functions

## SQL Best Practices
- Always check table structure before writing INSERT statements
- Use proper column names from actual database schema
- Include verification queries after data insertion
- Use `NOT EXISTS` for safe duplicate prevention

## Testing
- Create comprehensive test data with realistic values
- Include both custodial and non-custodial NFT types
- Test different subscription plans and user roles
- Verify all foreign key relationships

## Security Best Practices

### OWASP Top 10 Compliance
- **A01: Broken Access Control**
  - Implement proper authentication and authorization checks
  - Use Row Level Security (RLS) policies for all database tables
  - Validate user permissions before any data access
  - Implement principle of least privilege
  - Use JWT tokens with proper expiration and validation
  - Never trust client-side data for authorization decisions

- **A02: Cryptographic Failures**
  - Use strong encryption for sensitive data (AES-256)
  - Hash passwords with bcrypt (minimum 12 rounds)
  - Use HTTPS/TLS 1.3 for all communications
  - Implement proper key management and rotation
  - Encrypt data at rest in database
  - Use secure random number generation for tokens/seeds

- **A03: Injection**
  - Use parameterized queries and prepared statements
  - Validate and sanitize all user inputs
  - Implement input validation on both client and server
  - Use ORM/query builders to prevent SQL injection
  - Escape special characters in user-generated content
  - Implement Content Security Policy (CSP) headers

- **A04: Insecure Design**
  - Follow secure coding principles from design phase
  - Implement threat modeling for new features
  - Use secure defaults for all configurations
  - Implement proper error handling without information leakage
  - Design with security-by-default principles
  - Regular security architecture reviews

- **A05: Security Misconfiguration**
  - Remove default accounts and passwords
  - Disable unnecessary services and features
  - Keep all dependencies and frameworks updated
  - Use security headers (HSTS, CSP, X-Frame-Options)
  - Implement proper logging and monitoring
  - Regular security configuration audits

- **A06: Vulnerable and Outdated Components**
  - Maintain inventory of all dependencies
  - Regular dependency vulnerability scanning
  - Implement automated security updates where possible
  - Use tools like `npm audit` and `snyk` for vulnerability detection
  - Keep all libraries and frameworks current
  - Document and track all third-party components

- **A07: Identification and Authentication Failures**
  - Implement multi-factor authentication (MFA)
  - Use strong password policies (minimum 12 characters, complexity)
  - Implement account lockout after failed attempts
  - Use secure session management with proper timeouts
  - Implement proper logout functionality
  - Protect against credential stuffing attacks

- **A08: Software and Data Integrity Failures**
  - Implement code signing and integrity checks
  - Use secure CI/CD pipelines with signed artifacts
  - Implement supply chain security measures
  - Validate data integrity with checksums/hashes
  - Use secure update mechanisms
  - Implement tamper detection for critical data

- **A09: Security Logging and Monitoring Failures**
  - Implement comprehensive audit logging
  - Log all authentication and authorization events
  - Monitor for suspicious activities and anomalies
  - Implement real-time alerting for security events
  - Use centralized logging with proper retention
  - Regular log analysis and incident response procedures

- **A10: Server-Side Request Forgery (SSRF)**
  - Validate and sanitize all URLs and endpoints
  - Use allowlists for external service calls
  - Implement network segmentation
  - Use proper URL parsing and validation
  - Block access to internal/private networks
  - Implement request timeouts and size limits

### Database Security
- **CRITICAL: ONLY use Supabase Cloud Database** - Never connect to local databases
- Use Row Level Security (RLS) policies for all tables
- All database operations must use the cloud Supabase instance
- Never hardcode sensitive data in scripts or code
- Use environment variables for all configuration
- Implement database connection encryption
- Use parameterized queries exclusively
- Regular database security audits and updates
- Implement database access logging and monitoring

### Application Security
- Implement Content Security Policy (CSP) headers
- Use secure HTTP headers (HSTS, X-Frame-Options, X-Content-Type-Options)
- Implement proper CORS policies
- Use secure cookie settings (HttpOnly, Secure, SameSite)
- Implement rate limiting for API endpoints
- Use secure random number generation for all tokens
- Implement proper error handling without information disclosure
- Regular security testing and penetration testing

### Wallet and Blockchain Security
- Secure seed phrase generation and storage
- Implement hardware wallet support where possible
- Use secure key derivation functions (PBKDF2, scrypt)
- Implement proper wallet backup and recovery procedures
- Secure smart contract interaction and validation
- Implement transaction signing security measures
- Regular security audits of blockchain integrations

## Accessibility Best Practices

### WCAG 2.1 AA Compliance
- **Perceivable**
  - Provide alternative text for all images
  - Use sufficient color contrast (4.5:1 for normal text, 3:1 for large text)
  - Implement proper heading structure (h1-h6 hierarchy)
  - Provide captions for video content
  - Use semantic HTML elements
  - Ensure text can be resized up to 200% without loss of functionality

- **Operable**
  - Ensure all functionality is keyboard accessible
  - Provide sufficient time for users to read and use content
  - Avoid content that causes seizures (no flashing more than 3 times per second)
  - Provide ways to help users navigate and find content
  - Implement focus indicators for keyboard navigation
  - Use proper ARIA labels and roles

- **Understandable**
  - Use clear and simple language
  - Implement consistent navigation and functionality
  - Provide clear error messages and help text
  - Use proper form labels and instructions
  - Implement logical reading order
  - Provide context for abbreviations and jargon

- **Robust**
  - Use valid, semantic HTML markup
  - Implement proper ARIA attributes
  - Ensure compatibility with assistive technologies
  - Use progressive enhancement principles
  - Test with screen readers and other assistive tools
  - Maintain compatibility across different browsers and devices

### React/TypeScript Accessibility
- Use semantic HTML elements in JSX
- Implement proper ARIA attributes (aria-label, aria-describedby, role)
- Use React accessibility libraries (react-aria, reach-ui)
- Implement keyboard event handlers for custom components
- Use proper form validation with accessible error messages
- Implement focus management for modals and dynamic content
- Use proper color contrast in CSS/styled components
- Test components with accessibility testing tools

### Testing and Validation
- Regular accessibility audits using automated tools
- Manual testing with screen readers (NVDA, JAWS, VoiceOver)
- Keyboard-only navigation testing
- Color contrast validation
- Regular security vulnerability scanning
- Penetration testing for critical features
- Code security reviews and static analysis

## File Organization
- SQL scripts: descriptive names with version numbers
- Documentation: clear markdown files with step-by-step instructions
- Test data: comprehensive and realistic
- Fixes: include rollback instructions when possible

