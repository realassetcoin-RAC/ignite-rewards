-- Create the loyalty_change_requests table and related functionality
-- =====================================================

-- Create the loyalty_change_requests table
CREATE TABLE IF NOT EXISTS public.loyalty_change_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    change_type VARCHAR(100) NOT NULL,
    parameter_name VARCHAR(255) NOT NULL,
    old_value TEXT,
    new_value TEXT,
    reason TEXT,
    proposed_by UUID REFERENCES auth.users(id),
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'implemented')),
    dao_proposal_id UUID REFERENCES public.dao_proposals(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    implemented_at TIMESTAMP WITH TIME ZONE,
    implemented_by UUID REFERENCES auth.users(id)
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_loyalty_change_requests_status ON public.loyalty_change_requests(status);
CREATE INDEX IF NOT EXISTS idx_loyalty_change_requests_change_type ON public.loyalty_change_requests(change_type);
CREATE INDEX IF NOT EXISTS idx_loyalty_change_requests_proposed_by ON public.loyalty_change_requests(proposed_by);
CREATE INDEX IF NOT EXISTS idx_loyalty_change_requests_dao_proposal_id ON public.loyalty_change_requests(dao_proposal_id);

-- Create updated_at trigger function if it doesn't exist
CREATE OR REPLACE FUNCTION public.set_updated_at_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for updated_at
DROP TRIGGER IF EXISTS set_loyalty_change_requests_updated_at ON public.loyalty_change_requests;
CREATE TRIGGER set_loyalty_change_requests_updated_at
    BEFORE UPDATE ON public.loyalty_change_requests
    FOR EACH ROW
    EXECUTE FUNCTION public.set_updated_at_timestamp();

-- Create the DAO proposal trigger function
CREATE OR REPLACE FUNCTION public.create_dao_proposal_for_loyalty_change()
RETURNS TRIGGER AS $$
DECLARE
    proposal_id UUID;
    proposal_title TEXT;
    proposal_description TEXT;
    proposal_full_description TEXT;
    target_dao_id UUID;
BEGIN
    -- Only create proposal for new pending changes
    IF NEW.status = 'pending' AND (OLD IS NULL OR OLD.status != 'pending') THEN
        
        -- Get the correct DAO ID based on the change type
        -- Loyalty changes are technical changes, so they go to Platform Governance DAO
        SELECT id INTO target_dao_id 
        FROM dao_organizations 
        WHERE name = 'Platform Governance DAO' 
        AND is_active = true
        LIMIT 1;
        
        -- If no DAO found, skip proposal creation
        IF target_dao_id IS NULL THEN
            RAISE NOTICE 'No active Platform Governance DAO found, skipping proposal creation';
            RETURN NEW;
        END IF;
        
        -- Generate proposal details
        proposal_title := 'Loyalty Change: ' || 
            CASE NEW.change_type
                WHEN 'point_release_delay' THEN 'Point Release Delay'
                WHEN 'referral_parameters' THEN 'Referral Parameters'
                WHEN 'nft_earning_ratios' THEN 'NFT Earning Ratios'
                WHEN 'loyalty_network_settings' THEN 'Loyalty Network Settings'
                WHEN 'merchant_limits' THEN 'Merchant Limits'
                WHEN 'inactivity_timeout' THEN 'Inactivity Timeout'
                WHEN 'sms_otp_settings' THEN 'SMS OTP Settings'
                WHEN 'subscription_plans' THEN 'Subscription Plans'
                WHEN 'asset_initiative_selection' THEN 'Asset Initiative Selection'
                WHEN 'wallet_management' THEN 'Wallet Management'
                WHEN 'payment_gateway' THEN 'Payment Gateway'
                WHEN 'email_notifications' THEN 'Email Notifications'
                ELSE NEW.change_type
            END || ' - ' || NEW.parameter_name;
            
        proposal_description := 'Change ' || NEW.parameter_name || ' from "' || NEW.old_value || '" to "' || NEW.new_value || '"';
        
        proposal_full_description := '
# Loyalty Application Behavior Change

## Change Type
' || proposal_title || '

## Parameter
' || NEW.parameter_name || '

## Current Value
' || NEW.old_value || '

## Proposed Value
' || NEW.new_value || '

## Reason for Change
' || NEW.reason || '

## Impact Assessment
This change will affect the behavior of the loyalty application and requires community approval through DAO governance.

## Implementation
Once approved by the DAO, this change will be implemented automatically.

---
*This proposal was automatically generated by the loyalty governance system to ensure all behavior changes are properly governed.*';

        -- Create DAO proposal with the correct DAO ID
        INSERT INTO public.dao_proposals (
            dao_id,
            title,
            description,
            full_description,
            category,
            voting_type,
            status,
            treasury_impact_amount,
            treasury_impact_currency,
            tags,
            loyalty_change_id
        ) VALUES (
            target_dao_id,
            proposal_title,
            proposal_description,
            proposal_full_description,
            'technical',
            'simple_majority',
            'draft',
            0,
            'SOL',
            ARRAY['loyalty', 'governance', NEW.change_type],
            NEW.id
        ) RETURNING id INTO proposal_id;
        
        -- Update the loyalty change request with the proposal ID
        UPDATE public.loyalty_change_requests 
        SET dao_proposal_id = proposal_id 
        WHERE id = NEW.id;
        
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create the trigger
DROP TRIGGER IF EXISTS trigger_create_dao_proposal_for_loyalty_change ON public.loyalty_change_requests;
CREATE TRIGGER trigger_create_dao_proposal_for_loyalty_change
    AFTER INSERT OR UPDATE ON public.loyalty_change_requests
    FOR EACH ROW
    EXECUTE FUNCTION public.create_dao_proposal_for_loyalty_change();

-- Enable RLS on the table
ALTER TABLE public.loyalty_change_requests ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
DROP POLICY IF EXISTS "Users can view loyalty change requests" ON public.loyalty_change_requests;
CREATE POLICY "Users can view loyalty change requests" ON public.loyalty_change_requests
    FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can create loyalty change requests" ON public.loyalty_change_requests;
CREATE POLICY "Users can create loyalty change requests" ON public.loyalty_change_requests
    FOR INSERT WITH CHECK (auth.uid() = proposed_by);

DROP POLICY IF EXISTS "Users can update their own loyalty change requests" ON public.loyalty_change_requests;
CREATE POLICY "Users can update their own loyalty change requests" ON public.loyalty_change_requests
    FOR UPDATE USING (auth.uid() = proposed_by);

-- Insert some sample data for testing
INSERT INTO public.loyalty_change_requests (
    change_type,
    parameter_name,
    old_value,
    new_value,
    reason,
    proposed_by,
    status
) VALUES (
    'point_release_delay',
    'release_delay_days',
    '30',
    '45',
    'Increase point release delay to allow more time for merchant reversals',
    (SELECT id FROM auth.users LIMIT 1),
    'pending'
) ON CONFLICT DO NOTHING;

-- Verify the table and trigger were created
SELECT 
    table_name,
    column_name,
    data_type,
    is_nullable
FROM information_schema.columns 
WHERE table_name = 'loyalty_change_requests' 
AND table_schema = 'public'
ORDER BY ordinal_position;

-- Verify the trigger was created
SELECT 
    trigger_name,
    event_manipulation,
    event_object_table,
    action_statement
FROM information_schema.triggers 
WHERE trigger_name = 'trigger_create_dao_proposal_for_loyalty_change';
